## App lifecycle (intake ‚Üí plan ‚Üí build ‚Üí deploy ‚Üí operate)

A disciplined, budget-aware pipeline for taking an idea to production with dyads, resources, and guardrails.

### 1) Intake & scoping
- Capture intent, constraints, and target outcomes in `apps/<app>/docs/plan.md` (generated by `bin/start-app-project.sh`).
- Log human approvals or blockers via `/task` in Telegram (stored in manager).
- Assign department owner (e.g., webdev) and nominate a lead dyad (web-planner).

### 2) Teaming & resources
- Manager assigns dyads: planner (requirements), builder (implementation), QA (quality), infra (hosting), marketing (launch), creds (secrets/RBAC).
- Provision resources:
  - Per-app database via `bin/app-db-shared.sh create <app>`.
  - Repo + CI (queued in resource-broker if external APIs are needed).
  - UI visual baselines: create `ui-tests/targets.json` stub (auto-generated by `start-app-project.sh`).
- RBAC: grant only app-specific DB creds and repo access; request via `/access-requests` or `bin/request-access.sh`.

### 3) Plan & design
- Planner dyad fills `plan.md` sections: requirements, user journeys, success metrics, non-functional constraints, rollout plan, budget.
- Designer provides mocks; visual baselines added to `ui-tests/targets.json`.
- Approvals recorded as manager feedback or tasks.

### 4) Build
- Builder dyad codes in `apps/<app>/web` (SvelteKit/TypeScript) and `apps/<app>/backend` for Go services.
- Prefer shared packages (`packages/ui`, `packages/db`, `packages/auth`) over duplicating core logic.
- Unit/integ tests per app; add migrations under `apps/<app>/migrations`.
- Visual QA: `bin/qa-visual.sh <app>` to generate baseline and check diffs.
- Report progress via `/metrics` (throughput, lead time) and Telegram summaries.

### 5) Test & QA
- Automated: unit/integration, visual (`qa-visual.sh`), accessibility (axe via Playwright), smoke (`bin/qa-smoke.sh` pattern).
- Management: `bin/app-audit.sh` to validate app metadata/stack before deploy.
- Manual: if needed, create `/task` for human UX pass.
- Blockers: log via manager `/feedback` and `/human-tasks`; escalate with `bin/escalate-blockers.sh`.

### 6) Deploy
- Pre-deploy cost/safety: `bin/pre-deploy-check.sh` (üí∏ gate) and `pulumi-preview.sh` (prefer Pulumi for cloud).
- Build and deploy app stack: `bin/app-build.sh <app>` then `bin/app-deploy.sh <app>`.
- Infra dyad applies changes; report to Telegram with ‚úÖ/‚ö†Ô∏è and metrics `deploy_fail_rate`, `deploy_cost_delta`.
- Post-deploy smoke using existing QA scripts.

### 7) Operate & monitor
- Health: manager `/healthz`, service-level probes, periodic `health-monitor.sh` with Telegram alerts.
- Visual drift: scheduled `qa-visual.sh <app> --notify`.
- Metrics: autonomy ratio, blocker pressure, visual regressions, throughput; reported to manager `/metrics` and surfaced in Telegram status.
- Secrets: rotate per-app DB via `app-db-shared.sh drop/create` and update env; credentials dyad oversees rotations.

### Communication & oversight
- Telegram bot:
  - `/status`, `/tasks`, `/task` for human asks.
  - Replies to bot messages captured as contextual feedback.
- Manager:
  - `/human-tasks`, `/feedback`, `/access-requests`, `/metrics`, `/healthz`.
- Departments: each dyad posts brief status + blockers; manager aggregates into Telegram dashboard messages.

### Budget discipline
- Keep resource scope minimal per app: one DB, only necessary external integrations.
- Enforce cost checks pre-deploy; flag cost deltas via metrics and üí∏ Telegram notifications.
- Reuse base images and tools; keep visual/device matrix small (desktop + mobile).

### Checklist (per app)
- [ ] Repo + CI created (or queued)
- [ ] Per-app DB provisioned; creds stored
- [ ] Plan.md filled (requirements, success metrics, rollout)
- [ ] Visual targets defined; baseline captured
- [ ] Tests: unit/integration/visual/accessibility/smoke
- [ ] Deployment preview checked; cost gate passed
- [ ] Post-deploy smoke + metrics reported
- [ ] Monitoring hooks and rotations scheduled
