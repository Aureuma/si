package main

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"math"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"time"
)

const (
	reportBeginMarker    = "<<WORK_REPORT_BEGIN>>"
	reportEndMarker      = "<<WORK_REPORT_END>>"
	dyadTmuxHistoryLimit = "200000"
)

type loopConfig struct {
	Enabled          bool
	DyadName         string
	Role             string
	ActorContainer   string
	Goal             string
	StateDir         string
	SleepInterval    time.Duration
	StartupDelay     time.Duration
	TurnTimeout      time.Duration
	MaxTurns         int
	RetryMax         int
	RetryBase        time.Duration
	SeedCriticPrompt string
	PromptLines      int
	AllowMcpStartup  bool
	CaptureMode      string
	CaptureLines     int
	StrictReport     bool
	CodexStartCmd    string
	PausePoll        time.Duration
}

type loopState struct {
	Turn             int       `json:"turn"`
	LastActorReport  string    `json:"last_actor_report,omitempty"`
	LastCriticReport string    `json:"last_critic_report,omitempty"`
	UpdatedAt        time.Time `json:"updated_at"`
}

type turnExecutor interface {
	ActorTurn(ctx context.Context, prompt string) (string, error)
	CriticTurn(ctx context.Context, prompt string) (string, error)
}

type codexTurnExecutor struct {
	actorContainer string
	actorSession   string
	criticSession  string
	dyadName       string
	promptLines    int
	allowMcp       bool
	captureMode    string
	captureLines   int
	strictReport   bool
	startCmd       string
	readyTimeout   time.Duration
	turnTimeout    time.Duration
	pollInterval   time.Duration
}

var errCriticRequestedStop = errors.New("critic requested loop stop")
var errCodexAuthRequired = errors.New("codex authentication required")

func runCriticLoop(ctx context.Context, logger *log.Logger) error {
	cfg := loadLoopConfig()
	if !cfg.Enabled {
		return nil
	}
	if strings.TrimSpace(cfg.ActorContainer) == "" {
		return errors.New("dyad loop enabled but ACTOR_CONTAINER is missing")
	}
	if err := os.MkdirAll(cfg.StateDir, 0o755); err != nil {
		return fmt.Errorf("create state dir: %w", err)
	}
	maybeApplyHostOwnership(cfg.StateDir)
	if err := os.MkdirAll(filepath.Join(cfg.StateDir, "reports"), 0o755); err != nil {
		return fmt.Errorf("create report dir: %w", err)
	}
	maybeApplyHostOwnership(filepath.Join(cfg.StateDir, "reports"))
	logger.Printf("dyad loop enabled: dyad=%s actor=%s state_dir=%s", cfg.DyadName, cfg.ActorContainer, cfg.StateDir)
	if cfg.StartupDelay > 0 {
		logger.Printf("dyad loop startup delay: %s", cfg.StartupDelay)
		select {
		case <-ctx.Done():
			return nil
		case <-time.After(cfg.StartupDelay):
		}
	}
	if _, err := runCommand(ctx, "docker", "inspect", cfg.ActorContainer); err != nil {
		return fmt.Errorf("actor container preflight failed: %w", err)
	}
	executor, err := newCodexTurnExecutor(ctx, cfg)
	if err != nil {
		return err
	}
	return runTurnLoop(ctx, cfg, executor, logger)
}

func runTurnLoop(ctx context.Context, cfg loopConfig, executor turnExecutor, logger *log.Logger) error {
	statePath := filepath.Join(cfg.StateDir, "loop-state.json")
	state, err := loadLoopState(statePath)
	if err != nil {
		return err
	}
	// Respect control files immediately, before seeding/sending any prompts.
	for ctx.Err() == nil {
		stopRequestedByControl, pauseRequestedByControl := readLoopControl(cfg.StateDir)
		if stopRequestedByControl {
			logger.Printf("dyad loop stop requested by control file")
			return nil
		}
		if !pauseRequestedByControl {
			break
		}
		logger.Printf("dyad loop paused by control file")
		pauseFor := cfg.PausePoll
		if pauseFor <= 0 {
			pauseFor = 5 * time.Second
		}
		select {
		case <-ctx.Done():
			return nil
		case <-time.After(pauseFor):
		}
	}
	// If the dyad previously converged and the critic asked to stop, honor that across restarts.
	// This prevents "recreate" or container restarts from spinning up a new turn after the loop ended.
	if criticRequestsStop(state.LastCriticReport) {
		logger.Printf("dyad loop already stopped by prior critic report at turn %d", state.Turn)
		return nil
	}

	// Closed loop invariants:
	// - The actor only ever receives a message generated by the critic (stored in LastCriticReport).
	// - The critic only ever receives the actor's work report (we pass actorReport verbatim each turn).

	if strings.TrimSpace(state.LastCriticReport) != "" && containsCodexChrome(state.LastCriticReport) {
		logger.Printf("dyad loop state contains codex UI chrome; reseeding critic")
		state.LastCriticReport = ""
	}

	if strings.TrimSpace(state.LastCriticReport) == "" {
		seedPrompt := buildSeedCriticPrompt(cfg)
		seedRaw, seedReport, err := runWithRetries(ctx, cfg, "critic-seed", func(stepCtx context.Context) (string, string, error) {
			raw, err := executor.CriticTurn(stepCtx, seedPrompt)
			if err != nil {
				return "", "", err
			}
			report := extractDelimitedWorkReport(raw)
			if report == "" {
				return raw, "", errors.New("seed critic output missing message")
			}
			if criticMessageLooksPlaceholder(report) {
				return raw, "", errors.New("seed critic output looks placeholder")
			}
			return raw, report, nil
		})
		if err != nil {
			if errors.Is(err, errCodexAuthRequired) {
				logger.Printf("dyad seed halted (codex auth required): %v", err)
				return nil
			}
			// Never fall back to tool-generated actor prompts; that breaks the closed loop.
			return fmt.Errorf("dyad seed failed (cannot start without critic initiating): %w", err)
		}
		if err := writeTurnArtifacts(cfg.StateDir, 0, "critic", seedPrompt, seedRaw, seedReport); err != nil {
			logger.Printf("seed critic artifact warning: %v", err)
		}
		state.LastCriticReport = seedReport
		state.UpdatedAt = time.Now().UTC()
		if err := saveLoopState(statePath, state); err != nil {
			logger.Printf("dyad seed state save warning: %v", err)
		}
		logger.Printf("dyad seed critic report initialized")
		if criticRequestsStop(seedReport) {
			logger.Printf("dyad loop stop requested by critic seed report")
			return nil
		}
	}
	turn := state.Turn + 1
	failures := 0
	pausedNotified := false
	for ctx.Err() == nil {
		stopRequestedByControl, pauseRequestedByControl := readLoopControl(cfg.StateDir)
		if stopRequestedByControl {
			logger.Printf("dyad loop stop requested by control file")
			return nil
		}
		if pauseRequestedByControl {
			if !pausedNotified {
				logger.Printf("dyad loop paused by control file")
				pausedNotified = true
			}
			pauseFor := cfg.PausePoll
			if pauseFor <= 0 {
				pauseFor = 5 * time.Second
			}
			select {
			case <-ctx.Done():
				return nil
			case <-time.After(pauseFor):
			}
			continue
		}
		pausedNotified = false
		if cfg.MaxTurns > 0 && turn > cfg.MaxTurns {
			return nil
		}
		stopRequested, err := runSingleTurn(ctx, cfg, turn, &state, executor, logger)
		if err != nil {
			if errors.Is(err, errCriticRequestedStop) {
				if err := saveLoopState(statePath, state); err != nil {
					logger.Printf("dyad state save warning: %v", err)
				}
				logger.Printf("dyad loop stopped by critic at turn %d", turn)
				return nil
			}
			if errors.Is(err, errCodexAuthRequired) {
				logger.Printf("dyad loop halted (codex auth required): %v", err)
				return nil
			}
			failures++
			backoff := retryBackoff(cfg.RetryBase, failures)
			logger.Printf("dyad turn %d failed: %v (backoff %s)", turn, err, backoff)
			select {
			case <-ctx.Done():
				return nil
			case <-time.After(backoff):
				continue
			}
		}
		if err := saveLoopState(statePath, state); err != nil {
			logger.Printf("dyad state save warning: %v", err)
		}
		if stopRequested {
			logger.Printf("dyad loop stopped by critic at turn %d", turn)
			return nil
		}
		failures = 0
		turn++
		if cfg.SleepInterval > 0 {
			select {
			case <-ctx.Done():
				return nil
			case <-time.After(cfg.SleepInterval):
			}
		}
	}
	return nil
}

func runSingleTurn(ctx context.Context, cfg loopConfig, turn int, state *loopState, executor turnExecutor, logger *log.Logger) (bool, error) {
	actorPrompt := strings.TrimSpace(state.LastCriticReport)
	if actorPrompt == "" {
		return false, errors.New("cannot run actor turn: missing prior critic message")
	}
	actorRaw, actorReport, err := runWithRetries(ctx, cfg, "actor", func(stepCtx context.Context) (string, string, error) {
		raw, err := executor.ActorTurn(stepCtx, actorPrompt)
		if err != nil {
			return "", "", err
		}
		report := extractDelimitedWorkReport(raw)
		if report == "" {
			return raw, "", errors.New("actor output missing work report markers")
		}
		if actorReportLooksPlaceholderWithMode(report, cfg.StrictReport) {
			return raw, "", errors.New("actor output looks placeholder")
		}
		return raw, report, nil
	})
	if err != nil {
		return false, err
	}
	if err := writeTurnArtifacts(cfg.StateDir, turn, "actor", actorPrompt, actorRaw, actorReport); err != nil {
		logger.Printf("actor artifact warning: %v", err)
	}
	if err := appendTaskBoardTurnLog("/workspace/TASK_BOARD.md", cfg.DyadName, turn, actorReport); err != nil {
		logger.Printf("task board log warning: %v", err)
	}

	// Per requirement: critic receives ONLY the actor's report (no injected template).
	criticPrompt := actorReport
	criticRaw, criticReport, err := runWithRetries(ctx, cfg, "critic", func(stepCtx context.Context) (string, string, error) {
		raw, err := executor.CriticTurn(stepCtx, criticPrompt)
		if err != nil {
			return "", "", err
		}
		report := extractDelimitedWorkReport(raw)
		if report == "" {
			return raw, "", errors.New("critic output missing message")
		}
		if criticMessageLooksPlaceholder(report) {
			return raw, "", errors.New("critic output looks placeholder/empty")
		}
		return raw, report, nil
	})
	if err != nil {
		return false, err
	}
	if err := writeTurnArtifacts(cfg.StateDir, turn, "critic", criticPrompt, criticRaw, criticReport); err != nil {
		logger.Printf("critic artifact warning: %v", err)
	}

	state.Turn = turn
	state.LastActorReport = actorReport
	state.LastCriticReport = criticReport
	state.UpdatedAt = time.Now().UTC()
	logger.Printf("dyad turn %d complete", turn)
	if criticRequestsStop(criticReport) {
		return true, errCriticRequestedStop
	}
	return false, nil
}

func appendTaskBoardTurnLog(taskBoardPath string, dyad string, turn int, actorReport string) error {
	taskBoardPath = strings.TrimSpace(taskBoardPath)
	if taskBoardPath == "" {
		return nil
	}
	if _, err := os.Stat(taskBoardPath); err != nil {
		// Optional feature; do not fail turns if the board is missing.
		return nil
	}
	dyad = strings.TrimSpace(dyad)
	if dyad == "" {
		dyad = "unknown"
	}
	summary := extractActorReportSummary(actorReport)
	if len(summary) > 140 {
		summary = summary[:140] + "..."
	}
	ts := time.Now().UTC().Format(time.RFC3339)
	line := fmt.Sprintf("- %s ü™¢ %s üõ©Ô∏è actor Turn %d: %s\n", ts, dyad, turn, summary)
	f, err := os.OpenFile(taskBoardPath, os.O_APPEND|os.O_WRONLY, 0o644)
	if err != nil {
		return err
	}
	defer f.Close()
	if _, err := f.WriteString(line); err != nil {
		return err
	}
	maybeApplyHostOwnership(taskBoardPath)
	return nil
}

func extractActorReportSummary(actorReport string) string {
	// Prefer the first bullet under "Summary:" so task-board logs remain meaningful
	// even when the report's first line is just the section header.
	lines := strings.Split(strings.ReplaceAll(actorReport, "\r\n", "\n"), "\n")
	inSummary := false
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}
		lower := strings.ToLower(line)
		if strings.HasPrefix(lower, "summary:") {
			inSummary = true
			continue
		}
		if inSummary {
			// Stop at the next section header.
			if strings.HasSuffix(line, ":") && !strings.HasPrefix(line, "-") {
				break
			}
			if strings.HasPrefix(line, "-") {
				return strings.TrimSpace(strings.TrimPrefix(line, "-"))
			}
			return line
		}
	}
	// Fallback: first non-empty, non-header line.
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}
		if strings.HasSuffix(line, ":") && !strings.HasPrefix(line, "-") {
			continue
		}
		return strings.TrimSpace(strings.TrimPrefix(line, "-"))
	}
	return ""
}

func runWithRetries(ctx context.Context, cfg loopConfig, label string, fn func(context.Context) (string, string, error)) (string, string, error) {
	maxAttempts := cfg.RetryMax
	if maxAttempts < 1 {
		maxAttempts = 1
	}
	var lastErr error
	var raw string
	var report string
	for attempt := 1; attempt <= maxAttempts; attempt++ {
		stepCtx, cancel := context.WithTimeout(ctx, cfg.TurnTimeout)
		tmpRaw, tmpReport, err := fn(stepCtx)
		cancel()
		raw = tmpRaw
		report = tmpReport
		if err == nil {
			return raw, report, nil
		}
		lastErr = err
		if attempt == maxAttempts {
			break
		}
		select {
		case <-ctx.Done():
			return raw, report, ctx.Err()
		case <-time.After(retryBackoff(cfg.RetryBase, attempt)):
		}
	}
	return raw, report, fmt.Errorf("%s turn failed after retries: %w", label, lastErr)
}

func newCodexTurnExecutor(ctx context.Context, cfg loopConfig) (codexTurnExecutor, error) {
	sessionSuffix := sanitizeSessionName(cfg.DyadName)
	startCmd, err := interactiveCodexCommand(cfg.CodexStartCmd)
	if err != nil {
		return codexTurnExecutor{}, err
	}
	exec := codexTurnExecutor{
		actorContainer: cfg.ActorContainer,
		actorSession:   fmt.Sprintf("si-dyad-%s-actor", sessionSuffix),
		criticSession:  fmt.Sprintf("si-dyad-%s-critic", sessionSuffix),
		dyadName:       cfg.DyadName,
		promptLines:    cfg.PromptLines,
		allowMcp:       cfg.AllowMcpStartup,
		captureMode:    cfg.CaptureMode,
		captureLines:   cfg.CaptureLines,
		strictReport:   cfg.StrictReport,
		startCmd:       startCmd,
		readyTimeout:   cfg.TurnTimeout / 3,
		turnTimeout:    cfg.TurnTimeout,
		pollInterval:   350 * time.Millisecond,
	}
	if exec.promptLines <= 0 {
		exec.promptLines = 3
	}
	if exec.captureMode != "main" && exec.captureMode != "alt" {
		exec.captureMode = "main"
	}
	if exec.captureLines <= 0 {
		exec.captureLines = 8000
	}
	if exec.captureLines < 500 {
		exec.captureLines = 500
	}
	if exec.captureLines > 50000 {
		exec.captureLines = 50000
	}
	if exec.readyTimeout <= 0 {
		exec.readyTimeout = 30 * time.Second
	}
	if exec.pollInterval <= 0 {
		exec.pollInterval = 350 * time.Millisecond
	}

	if _, err := runCommand(ctx, "tmux", "-V"); err != nil {
		return codexTurnExecutor{}, fmt.Errorf("tmux preflight failed in critic container: %w", err)
	}
	if err := ensureActorContainerRunning(ctx, cfg.ActorContainer); err != nil {
		return codexTurnExecutor{}, err
	}
	if _, err := runCommand(ctx, "docker", "exec", cfg.ActorContainer, "tmux", "-V"); err != nil {
		return codexTurnExecutor{}, fmt.Errorf("tmux preflight failed in actor container: %w", err)
	}
	return exec, nil
}

func (e codexTurnExecutor) ActorTurn(ctx context.Context, prompt string) (string, error) {
	if err := ensureActorContainerRunning(ctx, e.actorContainer); err != nil {
		return "", err
	}
	runner := tmuxRunner{Prefix: []string{"docker", "exec", e.actorContainer}}
	out, err := e.runTurn(ctx, runner, e.actorSession, e.startCmd, prompt, "actor")
	if err != nil {
		e.recoverSession(e.actorSession, runner, err)
	}
	return out, err
}

func (e codexTurnExecutor) CriticTurn(ctx context.Context, prompt string) (string, error) {
	runner := tmuxRunner{}
	out, err := e.runTurn(ctx, runner, e.criticSession, e.startCmd, prompt, "critic")
	if err != nil {
		e.recoverSession(e.criticSession, runner, err)
	}
	return out, err
}

func (e codexTurnExecutor) runTurn(ctx context.Context, runner tmuxRunner, session string, startCmd string, prompt string, role string) (string, error) {
	paneTarget, readyOutput, err := e.ensureInteractiveSession(ctx, runner, session, startCmd, role)
	if err != nil {
		return "", err
	}
	cleanReady := stripANSI(readyOutput)
	// Baseline against a stable capture: when using tail capture (`capture-pane -S -N`),
	// byte offsets from one capture cannot be compared to another because the window
	// shifts as output grows. We keep a baseline end-marker index from a full-history
	// capture and only use it as a fallback when we cannot anchor on the echoed input.
	baselineReportEnd := strings.LastIndex(cleanReady, reportEndMarker)
	if baselineOut, capErr := tmuxCapture(ctx, runner, paneTarget, statusOptions{CaptureMode: e.captureMode, CaptureLines: 0}); capErr == nil {
		baselineReportEnd = strings.LastIndex(stripANSI(baselineOut), reportEndMarker)
	}
	if err := tmuxSendKeys(ctx, runner, paneTarget, "C-u"); err != nil {
		return "", err
	}
	normalizedPrompt := normalizeInteractivePrompt(prompt)
	if err := tmuxSendLiteral(ctx, runner, paneTarget, normalizedPrompt); err != nil {
		return "", err
	}
	if err := sleepContext(ctx, 150*time.Millisecond); err != nil {
		return "", err
	}
	if err := tmuxSendKeys(ctx, runner, paneTarget, "C-m"); err != nil {
		return "", err
	}
	return e.waitForTurnCompletion(ctx, runner, paneTarget, baselineReportEnd, role, normalizedPrompt)
}

func (e codexTurnExecutor) recoverSession(session string, runner tmuxRunner, cause error) {
	if !isRecoverableTurnErr(cause) {
		return
	}
	recoverCtx, cancel := context.WithTimeout(context.Background(), 4*time.Second)
	defer cancel()
	_, _ = runner.Output(recoverCtx, "kill-session", "-t", session)
}

func (e codexTurnExecutor) ensureInteractiveSession(ctx context.Context, runner tmuxRunner, session, startCmd string, role string) (string, string, error) {
	paneTarget := session + ":0.0"
	windowName := dyadTmuxWindowName(e.dyadName, role)
	if _, err := runner.Output(ctx, "has-session", "-t", session); err != nil {
		if _, err := runner.Output(ctx, "new-session", "-d", "-s", session, "-n", windowName, "bash", "-lc", startCmd); err != nil {
			return "", "", err
		}
	}
	applyDyadTmuxSessionDefaults(ctx, runner, session)
	_, _ = runner.Output(ctx, "rename-window", "-t", session+":0", windowName)
	_, _ = runner.Output(ctx, "select-pane", "-t", paneTarget, "-T", windowName)
	if out, err := runner.Output(ctx, "display-message", "-p", "-t", paneTarget, "#{pane_dead}"); err == nil && isTmuxPaneDeadOutput(out) {
		_, _ = runner.Output(ctx, "kill-session", "-t", session)
		if _, err := runner.Output(ctx, "new-session", "-d", "-s", session, "-n", windowName, "bash", "-lc", startCmd); err != nil {
			return "", "", err
		}
		applyDyadTmuxSessionDefaults(ctx, runner, session)
		_, _ = runner.Output(ctx, "rename-window", "-t", session+":0", windowName)
		_, _ = runner.Output(ctx, "select-pane", "-t", paneTarget, "-T", windowName)
	}
	_, _ = runner.Output(ctx, "resize-pane", "-t", paneTarget, "-x", "160", "-y", "60")
	output, err := e.waitForPromptReady(ctx, runner, paneTarget)
	if err != nil {
		return "", "", err
	}
	return paneTarget, output, nil
}

func dyadTmuxWindowName(dyad string, role string) string {
	dyad = strings.TrimSpace(dyad)
	if dyad == "" {
		dyad = "unknown"
	}
	switch strings.ToLower(strings.TrimSpace(role)) {
	case "actor":
		return "ü™¢ " + dyad + " üõ©Ô∏è actor"
	case "critic":
		return "ü™¢ " + dyad + " üß† critic"
	default:
		return "ü™¢ " + dyad
	}
}

func (e codexTurnExecutor) waitForPromptReady(ctx context.Context, runner tmuxRunner, target string) (string, error) {
	captureOpts := statusOptions{CaptureMode: e.captureMode, CaptureLines: e.captureLines}
	deadline := time.Now().Add(e.readyTimeout)
	var lastOutput string
	for time.Now().Before(deadline) {
		output, err := tmuxCapture(ctx, runner, target, captureOpts)
		if err == nil && strings.TrimSpace(output) != "" {
			lastOutput = output
		}
		clean := stripANSI(output)
		if codexAuthRequired(clean) {
			if strings.TrimSpace(lastOutput) == "" {
				lastOutput = output
			}
			if strings.TrimSpace(lastOutput) == "" {
				lastOutput = clean
			}
			return lastOutput, fmt.Errorf("%w: codex is prompting for sign-in; authenticate via `si login` or `si dyad peek` and complete the login flow", errCodexAuthRequired)
		}
		if codexPromptReady(clean, e.promptLines, e.allowMcp) {
			return output, nil
		}
		if err := sleepContext(ctx, e.pollInterval); err != nil {
			return "", err
		}
	}
	if lastOutput == "" {
		return "", errors.New("timeout waiting for codex prompt")
	}
	return lastOutput, errors.New("timeout waiting for codex prompt")
}

func (e codexTurnExecutor) waitForTurnCompletion(ctx context.Context, runner tmuxRunner, target string, baselineReportEnd int, role string, sentPrompt string) (string, error) {
	captureOpts := statusOptions{CaptureMode: e.captureMode, CaptureLines: e.captureLines}
	deadline := time.Now().Add(e.turnTimeout)
	var lastOutput string
	submitAttempts := 1
	lastSubmit := time.Now()
	sentPrompt = strings.TrimSpace(sentPrompt)
	sig := sentPrompt
	if len(sig) > 64 {
		sig = sig[:64]
	}
	for time.Now().Before(deadline) {
		output, err := tmuxCapture(ctx, runner, target, captureOpts)
		if err == nil && strings.TrimSpace(output) != "" {
			lastOutput = output
		}
		clean := stripANSI(output)
		promptReady := codexPromptReady(clean, e.promptLines, e.allowMcp)
		promptLine, hasPromptLine := lastCodexPromptLine(clean, e.promptLines)

		// Primary: anchor parsing to the echoed input line (or a short signature of it),
		// then extract the first delimited work report that appears after that anchor.
		after := -1
		if sig != "" {
			after = strings.LastIndex(clean, sig)
		}
		report, ok := extractDelimitedWorkReportAfter(clean, after)
		reportWasDelimited := ok
		if ok {
			if role == "actor" && actorReportLooksPlaceholderWithMode(report, e.strictReport) {
				ok = false
			}
			if role == "critic" && criticReportLooksPlaceholderWithMode(report, e.strictReport) {
				ok = false
			}
		}
		// Fallback: if we can't find the echoed prompt (e.g. Codex shows `[Pasted Content ...]`),
		// fall back to a stable full-history capture and look for a report after the prior end marker.
		if !ok && after < 0 && baselineReportEnd >= 0 {
			fullOut, fullErr := tmuxCapture(ctx, runner, target, statusOptions{CaptureMode: e.captureMode, CaptureLines: 0})
			if fullErr == nil && strings.TrimSpace(fullOut) != "" {
				fullClean := stripANSI(fullOut)
				if tmpReport, tmpOk := extractDelimitedWorkReportAfter(fullClean, baselineReportEnd); tmpOk {
					tmpReport = strings.TrimSpace(tmpReport)
					if tmpReport != "" {
						if role == "actor" && !actorReportLooksPlaceholderWithMode(tmpReport, e.strictReport) {
							return fullOut, nil
						}
						if role == "critic" && !criticReportLooksPlaceholderWithMode(tmpReport, e.strictReport) {
							return fullOut, nil
						}
					}
				}
			}
		}
		if !ok {
			// Fallback: scrape a structured report from the most recent prompt segment.
			//
			// Even in strict mode we should accept a complete sectioned report without explicit markers,
			// because real Codex output can omit them despite being semantically correct.
			segments := parsePromptSegmentsDual(clean, output)
			for i := len(segments) - 1; i >= 0; i-- {
				seg := segments[i]
				candidate := strings.TrimSpace(extractReportLinesFromLines(seg.Raw, seg.Lines, false))
				if candidate == "" {
					candidate = strings.TrimSpace(extractSectionedReportFromLines(seg.Lines))
				}
				if candidate == "" {
					continue
				}
				if role == "actor" && actorReportLooksPlaceholderWithMode(candidate, e.strictReport) {
					continue
				}
				if role == "critic" && criticReportLooksPlaceholderWithMode(candidate, e.strictReport) {
					continue
				}
				report = candidate
				ok = true
				reportWasDelimited = false
				break
			}
		}

		if ok && report != "" {
			// If we have an actual delimited report in the captured output, return it as-is.
			// Otherwise normalize by appending markers around the extracted report.
			//
			// Note: the echoed input prompt can itself contain the marker strings (the loop prompts
			// instruct the model to output them). So we must not treat `strings.Contains(clean, reportBeginMarker)`
			// as proof we received a delimited report.
			if reportWasDelimited {
				return output, nil
			}
			normalizedOutput := strings.TrimSpace(output)
			if normalizedOutput != "" {
				normalizedOutput += "\n"
			}
			normalizedOutput += reportBeginMarker + "\n" + report + "\n" + reportEndMarker
			return normalizedOutput, nil
		}

		if promptReady {
			// If the prompt line still looks like the just-entered input (e.g. `‚Ä∫ LONG_OUTPUT` or
			// `‚Ä∫ [Pasted Content ...]`), don't treat that as completion. Keep waiting for output.
			if hasPromptLine && codexPromptLineLooksLikeEcho(promptLine, sentPrompt) {
				if err := sleepContext(ctx, e.pollInterval); err != nil {
					return "", err
				}
				continue
			}
			if e.strictReport {
				// Avoid false positives immediately after submitting input (the prompt line can still be visible briefly).
				if time.Since(lastSubmit) <= 2*time.Second {
					if err := sleepContext(ctx, e.pollInterval); err != nil {
						return "", err
					}
					continue
				}
				// Sometimes Codex leaves the input line visible without actually submitting it. Nudge once.
				if submitAttempts < 2 && time.Since(lastSubmit) > 4*time.Second {
					_ = tmuxSendKeys(ctx, runner, target, "C-m")
					submitAttempts++
					lastSubmit = time.Now()
					if err := sleepContext(ctx, e.pollInterval); err != nil {
						return "", err
					}
					continue
				}
				if strings.TrimSpace(lastOutput) == "" {
					lastOutput = output
				}
				if strings.TrimSpace(lastOutput) == "" {
					return "", errors.New("codex prompt ready but missing work report markers")
				}
				return lastOutput, errors.New("codex prompt ready but missing work report markers")
			}
			if submitAttempts < 2 && time.Since(lastSubmit) > 4*time.Second {
				_ = tmuxSendKeys(ctx, runner, target, "C-m")
				submitAttempts++
				lastSubmit = time.Now()
			}
		}
		if err := sleepContext(ctx, e.pollInterval); err != nil {
			return "", err
		}
	}
	if lastOutput == "" {
		return "", errors.New("timeout waiting for codex report")
	}
	return lastOutput, errors.New("timeout waiting for codex report")
}

func lastCodexPromptLine(output string, promptLines int) (string, bool) {
	lines := strings.Split(output, "\n")
	if promptLines <= 0 {
		promptLines = 3
	}
	seen := 0
	for i := len(lines) - 1; i >= 0 && seen < promptLines*6; i-- {
		line := strings.TrimSpace(lines[i])
		if line == "" {
			continue
		}
		seen++
		if strings.HasPrefix(line, "‚Ä∫") {
			return line, true
		}
	}
	return "", false
}

func codexPromptLineLooksLikeEcho(promptLine string, sentPrompt string) bool {
	trimmed := strings.TrimSpace(strings.TrimPrefix(strings.TrimSpace(promptLine), "‚Ä∫"))
	if trimmed == "" {
		return false
	}
	lower := strings.ToLower(trimmed)
	if strings.Contains(lower, "[pasted content") {
		return true
	}
	sentPrompt = strings.TrimSpace(sentPrompt)
	if sentPrompt == "" {
		return false
	}
	// Compare against a short prefix to avoid huge string comparisons.
	sig := sentPrompt
	if len(sig) > 32 {
		sig = sig[:32]
	}
	return strings.Contains(trimmed, sig)
}

type tmuxRunner struct {
	Prefix []string
}

type statusOptions struct {
	CaptureMode  string
	CaptureLines int
}

func applyDyadTmuxSessionDefaults(ctx context.Context, runner tmuxRunner, session string) {
	session = strings.TrimSpace(session)
	if session == "" {
		return
	}
	_, _ = runner.Output(ctx, "set-option", "-t", session, "remain-on-exit", "off")
	_, _ = runner.Output(ctx, "set-option", "-t", session, "mouse", "on")
	_, _ = runner.Output(ctx, "set-option", "-t", session, "history-limit", dyadTmuxHistoryLimit)
}

func (r tmuxRunner) Output(ctx context.Context, args ...string) (string, error) {
	if len(args) == 0 {
		return "", errors.New("tmux args required")
	}
	if len(r.Prefix) == 0 {
		return runCommand(ctx, "tmux", args...)
	}
	cmdArgs := make([]string, 0, len(r.Prefix)-1+1+len(args))
	cmdArgs = append(cmdArgs, r.Prefix[1:]...)
	cmdArgs = append(cmdArgs, "tmux")
	cmdArgs = append(cmdArgs, args...)
	return runCommand(ctx, r.Prefix[0], cmdArgs...)
}

func runCommand(ctx context.Context, name string, args ...string) (string, error) {
	cmd := exec.CommandContext(ctx, name, args...)
	var stdout bytes.Buffer
	var stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr
	err := cmd.Run()
	out := strings.TrimSpace(stdout.String())
	if err != nil {
		msg := strings.TrimSpace(stderr.String())
		if msg != "" {
			if out != "" {
				return out, fmt.Errorf("%w: %s: %s", err, msg, out)
			}
			return out, fmt.Errorf("%w: %s", err, msg)
		}
		if out != "" {
			return out, fmt.Errorf("%w: %s", err, out)
		}
		return out, err
	}
	if errText := strings.TrimSpace(stderr.String()); errText != "" {
		out = strings.TrimSpace(strings.TrimSpace(out + "\n" + errText))
	}
	return out, nil
}

func ensureActorContainerRunning(ctx context.Context, container string) error {
	container = strings.TrimSpace(container)
	if container == "" {
		return errors.New("actor container required")
	}
	out, err := runCommand(ctx, "docker", "inspect", "-f", "{{.State.Running}}", container)
	if err == nil && isTrueString(out) {
		return nil
	}
	if _, startErr := runCommand(ctx, "docker", "start", container); startErr != nil {
		if err != nil {
			return fmt.Errorf("actor not running (%v) and start failed: %w", err, startErr)
		}
		return fmt.Errorf("start actor container: %w", startErr)
	}
	deadline := time.Now().Add(8 * time.Second)
	for time.Now().Before(deadline) {
		runningOut, inspectErr := runCommand(ctx, "docker", "inspect", "-f", "{{.State.Running}}", container)
		if inspectErr == nil && isTrueString(runningOut) {
			return nil
		}
		if err := sleepContext(ctx, 250*time.Millisecond); err != nil {
			return err
		}
	}
	return fmt.Errorf("actor container %s did not reach running state after restart", container)
}

func isTrueString(raw string) bool {
	raw = strings.TrimSpace(strings.ToLower(raw))
	return raw == "true" || raw == "1" || raw == "yes"
}

func isRecoverableTurnErr(err error) bool {
	if err == nil {
		return false
	}
	msg := strings.ToLower(err.Error())
	switch {
	case strings.Contains(msg, "timeout waiting for codex"):
		return true
	case strings.Contains(msg, "context deadline exceeded"):
		return true
	case strings.Contains(msg, "tmux"):
		return true
	case strings.Contains(msg, "pane"):
		return true
	case strings.Contains(msg, "session"):
		return true
	case strings.Contains(msg, "no such container"):
		return true
	case strings.Contains(msg, "is not running"):
		return true
	default:
		return false
	}
}

func readLoopControl(stateDir string) (stop bool, pause bool) {
	stateDir = strings.TrimSpace(stateDir)
	if stateDir == "" {
		return false, false
	}
	stopPath := filepath.Join(stateDir, "control.stop")
	pausePath := filepath.Join(stateDir, "control.pause")
	_, stopErr := os.Stat(stopPath)
	_, pauseErr := os.Stat(pausePath)
	return stopErr == nil, pauseErr == nil
}

func interactiveCodexCommand(custom string) (string, error) {
	custom = strings.TrimSpace(custom)
	if custom != "" {
		lower := strings.ToLower(custom)
		if strings.Contains(lower, "codex exec") || strings.Contains(lower, "codex-exec") {
			return "", errors.New("DYAD_CODEX_START_CMD must not use `codex exec`; dyads require interactive Codex")
		}
		return custom, nil
	}
	return strings.TrimSpace("export TERM=xterm-256color COLORTERM=truecolor COLUMNS=160 LINES=60 HOME=/root CODEX_HOME=/root/.codex; cd /workspace 2>/dev/null || true; codex --dangerously-bypass-approvals-and-sandbox"), nil
}

func normalizeInteractivePrompt(prompt string) string {
	prompt = strings.ReplaceAll(prompt, "\r\n", "\n")
	prompt = strings.ReplaceAll(prompt, "\r", "\n")
	prompt = strings.Join(strings.Fields(prompt), " ")
	return strings.TrimSpace(prompt)
}

func tmuxSendKeys(ctx context.Context, runner tmuxRunner, target string, keys ...string) error {
	if len(keys) == 0 {
		return nil
	}
	args := append([]string{"send-keys", "-t", target}, keys...)
	_, err := runner.Output(ctx, args...)
	return err
}

func tmuxSendLiteral(ctx context.Context, runner tmuxRunner, target, text string) error {
	if strings.TrimSpace(text) == "" {
		return nil
	}
	_, err := runner.Output(ctx, "send-keys", "-t", target, "-l", text)
	return err
}

func tmuxCapture(ctx context.Context, runner tmuxRunner, target string, opts statusOptions) (string, error) {
	start := "-"
	if opts.CaptureLines > 0 {
		start = fmt.Sprintf("-%d", opts.CaptureLines)
	}
	switch opts.CaptureMode {
	case "alt":
		return runner.Output(ctx, "capture-pane", "-t", target, "-p", "-J", "-S", start, "-a", "-q")
	case "main":
		return runner.Output(ctx, "capture-pane", "-t", target, "-p", "-J", "-S", start)
	default:
		return "", fmt.Errorf("unsupported tmux capture mode: %s", opts.CaptureMode)
	}
}

func sanitizeSessionName(raw string) string {
	raw = strings.TrimSpace(strings.ToLower(raw))
	if raw == "" {
		return "unknown"
	}
	var b strings.Builder
	for _, r := range raw {
		if (r >= 'a' && r <= 'z') || (r >= '0' && r <= '9') || r == '-' || r == '_' {
			b.WriteRune(r)
		}
	}
	out := b.String()
	if out == "" {
		return "unknown"
	}
	return out
}

func codexPromptReady(output string, promptLines int, allowMcpStartup bool) bool {
	lower := strings.ToLower(output)
	if !allowMcpStartup {
		if strings.Contains(lower, "starting mcp") || strings.Contains(lower, "mcp startup") {
			return false
		}
	}
	lines := strings.Split(output, "\n")
	if promptLines <= 0 {
		promptLines = 3
	}
	seen := 0
	for i := len(lines) - 1; i >= 0 && seen < promptLines*4; i-- {
		line := strings.TrimSpace(lines[i])
		if line == "" {
			continue
		}
		seen++
		if strings.HasPrefix(line, "‚Ä∫") {
			// Codex can render a prefilled suggestion on the prompt line; treat any visible prompt as ready.
			return true
		}
	}
	return false
}

func codexAuthRequired(output string) bool {
	lower := strings.ToLower(output)
	// Codex CLI shows this onboarding screen when no auth is present.
	if !strings.Contains(lower, "welcome to codex") {
		return false
	}
	return strings.Contains(lower, "sign in with chatgpt") ||
		strings.Contains(lower, "device code") ||
		strings.Contains(lower, "provide your own api key") ||
		strings.Contains(lower, "connect an api key")
}

type promptSegment struct {
	Prompt string
	Lines  []string
	Raw    []string
}

func parsePromptSegmentsDual(clean, raw string) []promptSegment {
	cleanLines := strings.Split(clean, "\n")
	rawLines := strings.Split(raw, "\n")
	if len(rawLines) < len(cleanLines) {
		pad := make([]string, len(cleanLines)-len(rawLines))
		rawLines = append(rawLines, pad...)
	}
	if len(cleanLines) < len(rawLines) {
		pad := make([]string, len(rawLines)-len(cleanLines))
		cleanLines = append(cleanLines, pad...)
	}
	segments := make([]promptSegment, 0, 8)
	var current *promptSegment
	for i, line := range cleanLines {
		rawLine := rawLines[i]
		trimmed := strings.TrimLeft(line, " ")
		if strings.HasPrefix(trimmed, "‚Ä∫") {
			if current != nil {
				segments = append(segments, *current)
			}
			prompt := strings.TrimSpace(strings.TrimPrefix(trimmed, "‚Ä∫"))
			current = &promptSegment{Prompt: prompt}
			continue
		}
		if current != nil {
			current.Lines = append(current.Lines, line)
			current.Raw = append(current.Raw, rawLine)
		}
	}
	if current != nil {
		segments = append(segments, *current)
	}
	return segments
}

func extractReportLinesFromLines(rawLines, cleanLines []string, ansi bool) string {
	max := len(cleanLines)
	if len(rawLines) < max {
		max = len(rawLines)
	}
	type block struct {
		raw   []string
		clean []string
	}
	var blocks []block
	var current block
	inReport := false
	workedLineRaw := ""
	workedLineClean := ""
	for i := 0; i < max; i++ {
		raw := strings.TrimRight(rawLines[i], " \t")
		clean := strings.TrimRight(cleanLines[i], " \t")
		cleanCore := strings.TrimLeft(clean, " ")
		if strings.Contains(strings.ToLower(cleanCore), "worked for") {
			workedLineRaw = raw
			workedLineClean = clean
		}
		if strings.HasPrefix(cleanCore, "‚Ä¢ ") {
			inReport = true
			current.raw = append(current.raw, raw)
			current.clean = append(current.clean, clean)
			continue
		}
		if !inReport {
			continue
		}
		if strings.TrimSpace(clean) == "" {
			if len(current.raw) > 0 {
				blocks = append(blocks, current)
				current = block{}
			}
			inReport = false
			continue
		}
		if strings.HasPrefix(clean, "  ") {
			current.raw = append(current.raw, raw)
			current.clean = append(current.clean, clean)
			continue
		}
		core := strings.TrimSpace(clean)
		if strings.HasPrefix(core, "‚ö†") || strings.HasPrefix(core, "Tip:") || strings.HasPrefix(core, "‚Ä∫") {
			if len(current.raw) > 0 {
				blocks = append(blocks, current)
			}
			current = block{}
			break
		}
		if strings.HasPrefix(core, "‚Ä¢ Starting MCP") || strings.HasPrefix(core, "‚Ä¢ Starting") {
			if len(current.raw) > 0 {
				blocks = append(blocks, current)
			}
			current = block{}
			break
		}
		current.raw = append(current.raw, raw)
		current.clean = append(current.clean, clean)
	}
	if len(current.raw) > 0 {
		blocks = append(blocks, current)
	}
	for i := len(blocks) - 1; i >= 0; i-- {
		block := blocks[i]
		if len(block.raw) == 0 {
			continue
		}
		if isTransientReport(block.clean) {
			continue
		}
		out := block.clean
		workedLine := workedLineClean
		if ansi {
			out = block.raw
			workedLine = workedLineRaw
		}
		for len(out) > 0 && strings.TrimSpace(out[len(out)-1]) == "" {
			out = out[:len(out)-1]
		}
		if workedLine != "" && !containsLine(out, workedLine) {
			out = append(out, workedLine)
		}
		return strings.Join(out, "\n")
	}
	return ""
}

func extractSectionedReportFromLines(lines []string) string {
	// Accept reports that are already in section-header form (e.g. fake-codex, or Codex output
	// that follows the protocol but omits explicit markers). This intentionally avoids capturing
	// Codex UI chrome like `Model:` or `Tip: ...`.
	if len(lines) == 0 {
		return ""
	}
	isHeader := func(s string) bool {
		s = strings.TrimSpace(s)
		if s == "" {
			return false
		}
		lower := strings.ToLower(s)
		return strings.HasPrefix(lower, "summary:") ||
			strings.HasPrefix(lower, "changes:") ||
			strings.HasPrefix(lower, "validation:") ||
			strings.HasPrefix(lower, "open questions:") ||
			strings.HasPrefix(lower, "next step for critic:") ||
			strings.HasPrefix(lower, "assessment:") ||
			strings.HasPrefix(lower, "risks:") ||
			strings.HasPrefix(lower, "required fixes:") ||
			strings.HasPrefix(lower, "verification steps:") ||
			strings.HasPrefix(lower, "next actor prompt:") ||
			strings.HasPrefix(lower, "continue loop:")
	}
	start := -1
	for i, line := range lines {
		if isHeader(line) {
			start = i
			break
		}
	}
	if start < 0 {
		return ""
	}
	out := make([]string, 0, len(lines)-start)
	for _, line := range lines[start:] {
		core := strings.TrimSpace(line)
		if core != "" {
			// Stop if we hit Codex chrome.
			if strings.HasPrefix(core, "Tip:") || strings.HasPrefix(core, "‚ö†") {
				break
			}
			lower := strings.ToLower(core)
			if strings.HasPrefix(lower, "model:") || strings.HasPrefix(lower, "directory:") {
				break
			}
		}
		out = append(out, line)
	}
	for len(out) > 0 && strings.TrimSpace(out[len(out)-1]) == "" {
		out = out[:len(out)-1]
	}
	return strings.TrimSpace(strings.Join(out, "\n"))
}

func isTransientReport(lines []string) bool {
	if len(lines) == 0 {
		return true
	}
	head := strings.TrimSpace(lines[0])
	if strings.HasPrefix(head, "‚Ä¢ Working") || strings.Contains(head, "esc to interrupt") {
		return true
	}
	if strings.HasPrefix(head, "‚Ä¢ Starting MCP") {
		return true
	}
	return false
}

func containsLine(lines []string, needle string) bool {
	for _, line := range lines {
		if line == needle {
			return true
		}
	}
	return false
}

func extractDelimitedWorkReport(output string) string {
	clean := strings.TrimSpace(strings.ReplaceAll(output, "\r\n", "\n"))
	if clean == "" {
		return ""
	}
	start := strings.LastIndex(clean, reportBeginMarker)
	end := strings.LastIndex(clean, reportEndMarker)
	if start >= 0 && end > start {
		body := strings.TrimSpace(clean[start+len(reportBeginMarker) : end])
		if body != "" {
			return body
		}
	}
	return ""
}

func extractDelimitedWorkReportAfter(output string, afterEnd int) (string, bool) {
	clean := strings.TrimSpace(strings.ReplaceAll(output, "\r\n", "\n"))
	if clean == "" {
		return "", false
	}
	end := strings.LastIndex(clean, reportEndMarker)
	if end < 0 || end <= afterEnd {
		return "", false
	}
	start := strings.LastIndex(clean[:end], reportBeginMarker)
	if start < 0 || start <= afterEnd {
		return "", false
	}
	body := strings.TrimSpace(clean[start+len(reportBeginMarker) : end])
	if body == "" {
		return "", false
	}
	return body, true
}

var (
	ansiCSI = regexp.MustCompile(`\x1b\[[0-?]*[ -/]*[@-~]`)
	ansiOSC = regexp.MustCompile(`\x1b\][^\x07]*(\x07|\x1b\\)`)
)

func stripANSI(s string) string {
	if s == "" {
		return s
	}
	out := ansiCSI.ReplaceAllString(s, "")
	return ansiOSC.ReplaceAllString(out, "")
}

func isTmuxPaneDeadOutput(out string) bool {
	out = strings.TrimSpace(out)
	return out == "1" || strings.EqualFold(out, "true") || strings.EqualFold(out, "yes")
}

func sleepContext(ctx context.Context, d time.Duration) error {
	if d <= 0 {
		return nil
	}
	t := time.NewTimer(d)
	defer t.Stop()
	select {
	case <-ctx.Done():
		return ctx.Err()
	case <-t.C:
		return nil
	}
}

func buildSeedCriticPrompt(cfg loopConfig) string {
	seed := strings.TrimSpace(cfg.SeedCriticPrompt)
	seedBlock := ""
	if seed != "" {
		seedBlock = "\nUser seed:\n" + seed + "\n"
	}
	return strings.TrimSpace(fmt.Sprintf(`
You are the CRITIC for the dyad "ü™¢ %s".

Goal: %s

Hard rules:
- You initiate: write the first message to the actor now.
- After this seed, your input will be ONLY the actor's work report (no templates).
- Your output will be sent verbatim to the actor.
- Keep it short; refer to /workspace/DYAD_PROTOCOL.md for the exact actor report format.

Task board:
- Use /workspace/TASK_BOARD.md as the queue.
- Tell the actor to pick ONE task, move it to Doing, and update TASK_BOARD.md each turn.

Vault:
- The actor may use `+"`si vault`"+` as needed; never print secret values.

Output requirement:
- Output ONLY the next actor message, delimited as:
  <<WORK_REPORT_BEGIN>>
  <message to actor>
  <<WORK_REPORT_END>>
%s
Now: write the first message to the actor to start useful work from TASK_BOARD.md.
`, cfg.DyadName, cfg.Goal, seedBlock))
}

func writeTurnArtifacts(stateDir string, turn int, member string, prompt string, raw string, report string) error {
	member = strings.TrimSpace(member)
	if member == "" {
		return errors.New("member required")
	}
	base := filepath.Join(stateDir, "reports", fmt.Sprintf("turn-%04d-%s", turn, member))
	if err := os.WriteFile(base+".prompt.txt", []byte(prompt+"\n"), 0o644); err != nil {
		return err
	}
	maybeApplyHostOwnership(base + ".prompt.txt")
	if err := os.WriteFile(base+".raw.txt", []byte(strings.TrimSpace(raw)+"\n"), 0o644); err != nil {
		return err
	}
	maybeApplyHostOwnership(base + ".raw.txt")
	if err := os.WriteFile(base+".report.md", []byte(strings.TrimSpace(report)+"\n"), 0o644); err != nil {
		return err
	}
	maybeApplyHostOwnership(base + ".report.md")
	return nil
}

func loadLoopState(path string) (loopState, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		if os.IsNotExist(err) {
			return loopState{}, nil
		}
		return loopState{}, err
	}
	var state loopState
	if err := json.Unmarshal(data, &state); err != nil {
		return loopState{}, err
	}
	return state, nil
}

func saveLoopState(path string, state loopState) error {
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0o755); err != nil {
		return err
	}
	maybeApplyHostOwnership(dir)
	tmp, err := os.CreateTemp(dir, "state-*.json")
	if err != nil {
		return err
	}
	defer os.Remove(tmp.Name())
	payload, err := json.MarshalIndent(state, "", "  ")
	if err != nil {
		_ = tmp.Close()
		return err
	}
	if _, err := tmp.Write(append(payload, '\n')); err != nil {
		_ = tmp.Close()
		return err
	}
	if err := tmp.Chmod(0o644); err != nil {
		_ = tmp.Close()
		return err
	}
	if err := tmp.Close(); err != nil {
		return err
	}
	if err := os.Rename(tmp.Name(), path); err != nil {
		return err
	}
	maybeApplyHostOwnership(path)
	return nil
}

func loadLoopConfig() loopConfig {
	dyad := envOr("DYAD_NAME", "unknown")
	member := strings.ToLower(envOr("DYAD_MEMBER", "critic"))
	defaultEnabled := member == "critic" && strings.TrimSpace(os.Getenv("ACTOR_CONTAINER")) != ""
	enabled := envBool("DYAD_LOOP_ENABLED", defaultEnabled)
	stateDir := strings.TrimSpace(os.Getenv("DYAD_STATE_DIR"))
	if stateDir == "" {
		stateDir = filepath.Join("/workspace", ".si", "dyad", dyad)
	}
	goal := strings.TrimSpace(os.Getenv("DYAD_LOOP_GOAL"))
	if goal == "" {
		goal = "Continuously improve the task outcome through actor execution and critic review."
	}
	return loopConfig{
		Enabled:          enabled,
		DyadName:         dyad,
		Role:             envOr("ROLE", "critic"),
		ActorContainer:   strings.TrimSpace(os.Getenv("ACTOR_CONTAINER")),
		Goal:             goal,
		StateDir:         stateDir,
		SleepInterval:    envDurationSeconds("DYAD_LOOP_SLEEP_SECONDS", 20),
		StartupDelay:     envDurationSeconds("DYAD_LOOP_STARTUP_DELAY_SECONDS", 2),
		TurnTimeout:      envDurationSeconds("DYAD_LOOP_TURN_TIMEOUT_SECONDS", 900),
		MaxTurns:         envInt("DYAD_LOOP_MAX_TURNS", 0),
		RetryMax:         envInt("DYAD_LOOP_RETRY_MAX", 3),
		RetryBase:        envDurationSeconds("DYAD_LOOP_RETRY_BASE_SECONDS", 2),
		SeedCriticPrompt: strings.TrimSpace(os.Getenv("DYAD_LOOP_SEED_CRITIC_PROMPT")),
		PromptLines:      envInt("DYAD_LOOP_PROMPT_LINES", 3),
		AllowMcpStartup:  envBool("DYAD_LOOP_ALLOW_MCP_STARTUP", false),
		CaptureMode:      strings.TrimSpace(strings.ToLower(envOr("DYAD_LOOP_TMUX_CAPTURE", "main"))),
		CaptureLines:     envInt("DYAD_LOOP_TMUX_CAPTURE_LINES", 8000),
		// Default to tolerant parsing so the loop works with real Codex output, which can be
		// structurally correct while omitting our explicit marker strings.
		StrictReport:  envBool("DYAD_LOOP_STRICT_REPORT", false),
		CodexStartCmd: strings.TrimSpace(os.Getenv("DYAD_CODEX_START_CMD")),
		PausePoll:     envDurationSeconds("DYAD_LOOP_PAUSE_POLL_SECONDS", 5),
	}
}

func envBool(key string, def bool) bool {
	raw := strings.TrimSpace(strings.ToLower(os.Getenv(key)))
	if raw == "" {
		return def
	}
	switch raw {
	case "1", "true", "yes", "on":
		return true
	case "0", "false", "no", "off":
		return false
	default:
		return def
	}
}

func envInt(key string, def int) int {
	raw := strings.TrimSpace(os.Getenv(key))
	if raw == "" {
		return def
	}
	value, err := strconv.Atoi(raw)
	if err != nil {
		return def
	}
	return value
}

func envDurationSeconds(key string, defSeconds int) time.Duration {
	value := envInt(key, defSeconds)
	if value < 0 {
		value = 0
	}
	return time.Duration(value) * time.Second
}

func retryBackoff(base time.Duration, attempt int) time.Duration {
	if base <= 0 {
		base = time.Second
	}
	if attempt < 1 {
		attempt = 1
	}
	multiplier := math.Pow(2, float64(attempt-1))
	d := time.Duration(float64(base) * multiplier)
	max := 30 * time.Second
	if d > max {
		return max
	}
	return d
}

func criticRequestsStop(report string) bool {
	lines := strings.Split(strings.ToLower(strings.TrimSpace(report)), "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}
		if strings.Contains(line, "continue loop: no") || strings.Contains(line, "continue_loop=no") || strings.Contains(line, "loop_continue=false") {
			return true
		}
		if strings.Contains(line, "stop loop: yes") || strings.Contains(line, "stop_loop=true") || strings.Contains(line, "#stop_loop") {
			return true
		}
	}
	return false
}

func criticMessageLooksPlaceholder(msg string) bool {
	// Critic output is sent verbatim to the actor as the next prompt. We accept free-form text,
	// but reject empty/template-y outputs.
	if containsCodexChrome(msg) {
		return true
	}
	norm := normalizeReportText(msg)
	if strings.TrimSpace(norm) == "" {
		return true
	}
	if strings.Contains(norm, "summary: - ...") || strings.Contains(norm, "assessment: - ...") {
		return true
	}
	if strings.Count(norm, "...") >= 3 {
		return true
	}
	words := strings.Fields(norm)
	if len(words) == 0 {
		return true
	}
	if len(words) == 1 {
		switch words[0] {
		case "ok", "okay":
			return true
		default:
			return false
		}
	}
	return false
}

func actorReportLooksPlaceholderWithMode(report string, strict bool) bool {
	if containsCodexChrome(report) {
		return true
	}
	norm := normalizeReportText(report)
	if !strict {
		// Tolerant mode: accept Codex-native bullet reports and other structured text as long as it
		// isn't obviously a placeholder template.
		if strings.TrimSpace(norm) == "" {
			return true
		}
		// Reject the template-y skeleton.
		if strings.Contains(norm, "summary: - ...") && strings.Contains(norm, "changes: - ...") {
			return true
		}
		if strings.Count(norm, "...") >= 3 {
			return true
		}
		// Accept if it contains any meaningful bullets or common Codex sections.
		if strings.Contains(report, "‚Ä¢ ") || strings.Contains(report, "\n‚Ä¢ ") ||
			strings.Contains(report, "\n- ") || strings.Contains(report, "\n‚îî") ||
			strings.Contains(norm, "explored") || strings.Contains(norm, "changed") ||
			strings.Contains(norm, "validation") || strings.Contains(norm, "next") {
			return false
		}
		// Otherwise, require at least a few words.
		return len(strings.Fields(norm)) < 8
	}
	// Require the report to include the expected section headers. Without these, it is almost
	// certainly a truncated, aborted, or placeholder response (and breaks downstream prompting).
	if !strings.Contains(norm, "summary:") ||
		!strings.Contains(norm, "changes:") ||
		!strings.Contains(norm, "validation:") ||
		!strings.Contains(norm, "open questions:") ||
		!strings.Contains(norm, "next step for critic:") {
		return true
	}
	if strings.Contains(norm, "summary: changes: validation: open questions: next step for critic:") {
		return true
	}
	if strings.Contains(norm, "summary: - ...") && strings.Contains(norm, "changes: - ...") && strings.Contains(norm, "validation: - ...") {
		return true
	}
	if strings.Contains(norm, "<at least") || strings.Contains(norm, "<specific") || strings.Contains(norm, "<what you") {
		return true
	}
	if strings.Count(norm, "...") >= 2 && reportBulletCount(report) <= 2 {
		return true
	}
	if strings.Contains(norm, "summary:") && strings.Contains(norm, "changes:") && reportBulletCount(report) < 2 {
		return true
	}
	return false
}

func criticReportLooksPlaceholderWithMode(report string, strict bool) bool {
	if containsCodexChrome(report) {
		return true
	}
	norm := normalizeReportText(report)
	if !strict {
		if strings.TrimSpace(norm) == "" {
			return true
		}
		if strings.Contains(norm, "assessment: - ...") && strings.Contains(norm, "required fixes: - ...") {
			return true
		}
		if strings.Count(norm, "...") >= 3 {
			return true
		}
		// Accept Codex-native bullet critiques.
		if strings.Contains(report, "‚Ä¢ ") || strings.Contains(report, "\n‚Ä¢ ") || strings.Contains(report, "\n- ") {
			return false
		}
		// Otherwise require some substance.
		return len(strings.Fields(norm)) < 10
	}
	// Require the report to include the expected section headers, including a concrete continue flag.
	if !strings.Contains(norm, "assessment:") ||
		!strings.Contains(norm, "risks:") ||
		!strings.Contains(norm, "required fixes:") ||
		!strings.Contains(norm, "verification steps:") ||
		!strings.Contains(norm, "next actor prompt:") ||
		!strings.Contains(norm, "continue loop:") {
		return true
	}
	if strings.Contains(norm, "continue loop: yes|no") ||
		strings.Contains(norm, "continue loop: <yes|no>") ||
		strings.Contains(norm, "continue loop: - yes|no") {
		return true
	}
	if !strings.Contains(norm, "continue loop: yes") && !strings.Contains(norm, "continue loop: no") &&
		!strings.Contains(norm, "continue_loop=yes") && !strings.Contains(norm, "continue_loop=no") &&
		!strings.Contains(norm, "loop_continue=true") && !strings.Contains(norm, "loop_continue=false") {
		return true
	}
	if strings.Contains(norm, "assessment: risks: required fixes: verification steps: next actor prompt: continue loop: yes|no") {
		return true
	}
	if strings.Contains(norm, "assessment: - ...") &&
		strings.Contains(norm, "required fixes: - ...") &&
		strings.Contains(norm, "verification steps: - ...") &&
		strings.Contains(norm, "next actor prompt: - ...") {
		return true
	}
	if strings.Contains(norm, "continue loop: <yes|no>") || strings.Contains(norm, "<clear actionable") || strings.Contains(norm, "<single concrete") {
		return true
	}
	if strings.Count(norm, "...") >= 2 && reportBulletCount(report) <= 3 {
		return true
	}
	if strings.Contains(norm, "assessment:") && strings.Contains(norm, "required fixes:") && reportBulletCount(report) < 3 {
		return true
	}
	return false
}

func normalizeReportText(s string) string {
	s = strings.ToLower(strings.TrimSpace(s))
	s = strings.ReplaceAll(s, "\r\n", "\n")
	s = strings.ReplaceAll(s, "\r", "\n")
	s = strings.Join(strings.Fields(s), " ")
	return s
}

func containsCodexChrome(s string) bool {
	// Reject Codex UI chrome that can leak into tmux captures and break the dyad loop.
	if s == "" {
		return false
	}
	lower := strings.ToLower(s)
	if strings.Contains(lower, "openai codex") ||
		strings.Contains(lower, "context left") ||
		strings.Contains(lower, "model to change") ||
		strings.Contains(lower, "directory:") ||
		strings.Contains(lower, "tip:") ||
		strings.Contains(lower, "? for shortcuts") {
		return true
	}
	// Box drawing characters used in Codex's UI.
	if strings.Contains(s, "‚ï≠") || strings.Contains(s, "‚ï∞") || strings.Contains(s, "‚ïØ") || strings.Contains(s, "‚îÇ") {
		return true
	}
	return false
}

func reportBulletCount(report string) int {
	lines := strings.Split(strings.ReplaceAll(report, "\r\n", "\n"), "\n")
	count := 0
	for _, line := range lines {
		trimmed := strings.TrimSpace(line)
		if strings.HasPrefix(trimmed, "- ") || strings.HasPrefix(trimmed, "* ") || strings.HasPrefix(trimmed, "‚Ä¢ ") {
			count++
		}
	}
	return count
}

func maybeApplyHostOwnership(path string) {
	uid, gid, ok := hostOwnership()
	if !ok {
		return
	}
	_ = os.Chown(path, uid, gid)
}

func hostOwnership() (int, int, bool) {
	uid := envInt("SI_HOST_UID", 0)
	gid := envInt("SI_HOST_GID", 0)
	if uid <= 0 || gid <= 0 {
		return 0, 0, false
	}
	return uid, gid, true
}
